(**
    The state of a game of Camlished
 *)

(** The type representing coordinates *)
type coordinates = (int*int)

(** The type representing a resource *)
type resource = {
  id: GameData.resource_type;
  amount: int;
}

(** The type representing a person *)
type person = string

(** The type representing a building *)
type building = {
  building_type: GameData.building_type;
  coordinates: coordinates;
  workers: person list;
  residents: person list;
}

(** The type representing a tile *)
type tile

(** The type representing a game state *)
type t

(** Raised in an attempt to perform an operation on a non defined resource *)
exception IllegalResourceType

(** Raised in failure to collect a resource *)
exception IllegalResourceCollection

(** Raised in an attempt to assign a worker to a nonexistent building,
    or if there are not enough workers. *)
exception IllegalWorkerAssignment 

(** [clear_log ()] clears the internal messaging system *)
val clear_log : unit -> unit

(** [log s] adds [s] to the internal messaging *)
val log : string -> unit

(** [read_log ()] is the list of messages *)
val read_log : unit -> string list

(** [from_json j] is the user data that [j] represents.
    Requires: [j] is a valid JSON game state representation. *)
val from_json : Yojson.Basic.t -> t

(** [from_json_testing j] is the user data that [j] represents, with test dt
    Requires: [j] is a valid JSON game state representation. *)
val from_json_testing : Yojson.Basic.t -> t

(** [save st] saves the game by writing the game state to the data file. *)
val save : t -> unit

(** [initial_state name] gives a randomly generated initial game state. *)
val initial_state : string -> t

(** [world_name st] gives the name of the world associated with [st] *)
val world_name : t -> string

(** [update_rsc u_rsc st] updates the resource list in [st] with the
    resource type and amount associated with [u_rsc].
    Creates new resource if [u_rsc] not found. 
    Reqruies: u_rsc is a valid resource type *)
val update_rsc : resource -> t -> t

(** [get_rsc_amt rsc st] gives the amount of resource type [rsc] in [st]. *)
val get_rsc_amt : GameData.resource_type -> t -> int

(** [building_consumption_gen b st] updates the state with the resources 
    consumed and generated by [b] *)
val building_consumption_gen : building -> t -> t

(** [building_active_gen b st] updates the state with the resources actively
    generated by [b] *)
val building_active_gen : building -> t -> t

(** [active_gen_rsc_amt b st] gives the list of resources as well as their 
    amounts that are actively generated by [b] in [st] *)
val active_gen_rsc_amt : building -> t -> resource list

(** [con_gen_rsc_amt b st] gives a (resource * resource) list of the
    resources that can be generated by a building in [st] where the first 
    resource is the required input and the second resource is the output  *)
val con_gen_rsc_amt : building -> t -> (resource * resource) list

(** [step st] steps one turn through the game state [st]. *)
val step : t -> t

(** [turns st] is the number of turns in [st] *)
val turns : t -> int

(** [year st] is the current year in [st] *)
val year : t -> int

(** [season st] is the current season in [st] *)
val season : t -> GameData.season

(** [get_buildings st] gives a list of all the buildings on the state's map. *)
val get_buildings : t -> building list

(** [get_tiles st] gives a list of all the tiles on the state's map. *)
val get_tiles : t -> tile list

(** [get_game_data st] gives the game data. *)
val get_game_data : t -> GameData.t

(** [get_user_resources st] is the list of resources the user has *)
val get_user_resources : t -> (string * int) list

(** [get_building_at coor st] returns the building option of
    the building located coordinates [coor] on the state map.
    Returns None if there is no building. *)
val get_building_at : coordinates -> t -> building option

(** [get_building_type_at coor st] returns the building_type option of
    the building located the coordinates [coor] on the state map.
    Returns None if there is no building. *)
val get_building_type_at : coordinates -> t -> GameData.building_type option

(** [get_tile_at coor st] returns the tile_type option of the tile
    at coordinates [coor] on the state map. Returns None if tile is empty. *)
val get_tile_at : coordinates -> t -> GameData.tile_type option

(** [tile_rep_at coor st] returns the tile_type of the tile
    at the coordinates [coor] on the state map.
    Returns Grass if tile is empty. *)
val tile_rep_at : coordinates -> t -> GameData.tile_type

(** [is_empty coor st] gives whether or not a tile at the coordinates [coor]
    is empty *)
val is_empty : coordinates -> t -> bool

(** [meets_rsc_reqs bt st] gives whether the resources in [st] meet the resource
    requirements for the placement of building type [bt] *)
val meets_rsc_reqs : GameData.building_type -> t -> bool

(** [meets_placement_reqs bt coor st] gives whether the tile at or
    next to [coor] meets the placement requirements of building type [bt] *)
val meets_placement_reqs : GameData.building_type -> coordinates -> t -> bool

(** [is_valid_bt bt st] gives whether [bt] is a valid building type defined 
    in the game data of [st] *)
val is_valid_bt :  GameData.building_type -> t -> bool

(** [can_place_building bt coor st] gives whether or not a building of type 
    [bt] can be placed on [coor]. Returns true if [st] meets building placement 
    requirements and the tile at [coor] is unoccupied. *)
val can_place_building_at : GameData.building_type -> coordinates -> t -> bool

(** [place_building building_type coor worker_amt st] places a building of the
    type [building_type] on the state map at the coordinates [coor]. *)
val place_building : GameData.building_type -> coordinates -> t -> t

(** [population st] gives the numerical population of [st]. *)
val population : t -> int

(** [all_residents st] is the list of all people who live in [st] *)
val all_residents : t -> person list

(** [assigned_workers st] is the list of all people with job who live in [st] *)
val assigned_workers : t -> person list

(** [unassigned_workers st] is the list of people who don't have job in [st] *)
val unassigned_workers : t -> person list

(** [assign_workers_b b amt st] assigns [amt] workers to [b],
    raising IllegalWorkerAssignment if not enough unassigned workers. *)
val assign_workers_b : building -> int -> t -> t

(** [assign_workers_c coor amt st] assigns [amt] workers to the building at
    [coor] if possible, else raises IllegalWorkerAssignment. *)
val assign_workers_c : coordinates -> int -> t -> t

(** [unassign_workers_b b amt st] unassigns [amt] workers or the max possible
    from [b], raising IllegalWorkerAssignment if trying to unassign negative. *)
val unassign_workers_b : building -> int -> t -> t

(** [unassign_workers_c coor amt st] unassigns [amt] workers from building at
    [coor] if possible, else raises IllegalWorkerAssignment. *)
val unassign_workers_c : coordinates -> int -> t -> t

(** [building_residents b] is the list of residents at [b] *)
val building_residents : building -> person list

(** [building_workers b] is the list of workers at [b] *)
val building_workers : building -> person list

(** [max_population st] is the sum of max residents of each building in [st] *)
val max_population : t -> int

(** [cap_list_length n l] is [l] with at most [n] elements, from front *)
val cap_list_length : int -> 'a list -> 'a list

(** [living_residents bl] is the list of people living in the buildings in [bl].
    Intended for use by life and death *)
val living_residents : building list -> person list

(** [remove_ppl p l] is [l] randomly removing people with probability [p] *)
val remove_ppl : float -> person list -> person list

(** [death_chance food warmth season st] is the death chance using [st] game
    data, based on food, warmth, and season *)
val death_chance : int -> float -> GameData.season -> t -> float

(** [kill_residents b st] is [b] after [kill_some] with death rate from [st] *)
val kill_residents : building -> t -> building

(** [clean_dead_workers b living] is [b] after removing workers that are no
    longer in the [living] *)
val clean_dead_workers : building -> person list -> building

(** [step_deaths bl st] is [bl] after culling and cleaning each building.
    [st] is only used for its game data -> death chance *)
val step_deaths : building list -> t -> building list

(** [new_residents p l] is the list of babies possibly born to people in [l]
    with probability [p] each *)
val new_residents : float -> person list -> person list

(** [baby_to_building name b st] is a pair [(bool, b)] with [b] after trying to
    add [name] to its list of residents. [bool] is [true] if there was space and
    the operation succeeded, [false] otherwise. *)
val baby_to_building : string -> building -> t -> bool * building

(** [dist_babies babies st b_arr] is the building array after distributing
    [babies] randomly to each building if it has space. Requires that the
    buildings collectively have enough space remaining for the babies. *)
val dist_babies : string list -> t -> building array -> building array

(** [step_births bl st] is [bl] after creating new residents and assigning them
    to buildings as residents if necessary. *)
val step_births : building list -> t -> building list

(** [eat_food st] is [st] after the residents in the building list eat food, to
    a minimum of 0 food *)
val eat_food : t -> t

(** [alive st] is if there are still living people in [st] *)
val alive : t -> bool

(** [get_bounds st] returns the bounds of the game *)
val get_bounds : t -> GameData.bounds

(** [get_test_building] generates a building for testing *)
val get_test_building : building

(** [get_test_tile] generates a [tile_type] for testing *)
val get_test_tile : GameData.tile_type

(** [get_test_placed_buildings] gives a list of
    buildings for placement testing *)
val get_test_placed_buildings : building list

(** [get_test_food] generates a food resource for resource testing *)
val get_test_food : resource

(** [get_test_planks] generates a plank resource for resource testing *)
val get_test_planks : resource

(** [get_test_wood] generates a wood resource for resource testing *)
val get_test_wood : resource

(** [get_test_metal] generates a metal resource for resource testing *)
val get_test_metal : resource

(** [get_test_ore] generates a ore resource for resource testing *)
val get_test_ore : resource

(** [get_test_stone] generates a stone resourcefor resource testing *)
val get_test_stone : resource

(** [get_test_food] generates a food resource type for resource testing *)
val get_test_food_type : GameData.resource_type

(** [get_test_planks] generates a plank resource type for resource testing *)
val get_test_planks_type : GameData.resource_type

(** [get_test_wood] generates a wood resource type for resource testing *)
val get_test_wood_type : GameData.resource_type

(** [get_test_metal] generates a metal resource type for resource testing *)
val get_test_metal_type : GameData.resource_type

(** [get_test_ore] generates a ore resource type for resource testing *)
val get_test_ore_type : GameData.resource_type

(** [get_test_stone] generates a stone resource type for resource testing *)
val get_test_stone_type : GameData.resource_type
